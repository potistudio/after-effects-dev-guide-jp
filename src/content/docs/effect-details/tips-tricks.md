---
title: 'ヒントとコツ'
---
## ベストプラクティス

あなたのプロトタイプが私たちのものと似ている場合、クラッシュせずに実行されるプラグインの最初のバージョンは、実際に出荷されるバージョンとは大きく異なります。

ダウンサンプリング、エラーと例外、ピクセル アスペクト比、メモリ不足の状況、処理中の中断などにプラグインがどのように対応するかによって、プラグインがどの程度使いやすいか (そして処理しなければならないサポート リクエストの数) が決まります。

---

## 応答性

[Interaction Callbacks](interaction-callback-functions#interaction-callbacks) の `PF_ABORT()` と `PF_PROGRESS()` を使用して、プラグインの応答性を可能な限り高めます。

実際に、すべてのエフェクトの割り込み能力をテストします。フィルム解像度シーケンスの処理が完了するまでポーキー エフェクトを待ち続ける気難しいユーザーには驚かれるでしょう。

After Effects の反復関数は本質的にこの機能を提供します。ピクセル処理関数内から上記の関数を呼び出すことを心配する必要はありません。

---

## エフェクトを見つけやすくする

ユーザーがプラグイン名以外のものを検索したときに、「エフェクトとプリセット」パレットにエフェクトを表示させることができます。

エフェクトを適用し（ユーザーが特定の用語を検索するときに別のものが必要であると確信している場合を除き、設定はデフォルトのままにしておきます）、エフェクト コントロール パレットから [選択範囲をアニメーション プリセットとして保存] を選択します。

ユーザーがプラグインを見つけられるようにする名前で保存します。

プラグインのインストーラーに、結果の .ffx ファイルを \\Presets ディレクトリの After Effects 実行可能ファイルの隣に配置させます。

プリセットは、ユーザーが保存された名前を検索すると表示されます。

---

## (x,y) でのピクセルのサンプリング

場合によっては、すべてのピクセルを処理するのではなく、入力フレーム内の特定のオフセットに到達したい場合があります。以下は、特定の (x,y) 位置でピクセルをサンプリングする 1 つの方法です。同様のコードを使用して、指定された場所に書き込むことができます。

```cpp
PF_Pixel *sampleIntegral32(PF_EffectWorld &def, int x, int y){
    return (PF_Pixel*)((char*)def.data +
        (y * def.rowbytes) +
        (x * sizeof(PF_Pixel)));
}

PF_Pixel16 *sampleIntegral64(PF_EffectWorld &def, int x, int y){
    assert(PF_WORLD_IS_DEEP(&def));
    return (PF_Pixel16*)((char*)def.data +
        (y * def.rowbytes) +
        (x * sizeof(PF_Pixel16)));
}
```
この質問に答えてくれた Paul Miller に感謝します。

---

## ピクセルの中心はどこですか?

いやあ、おい。 After Effects は、アンカーポイント（ユーザードキュメントを参照）が (0,0) の場合、左上のピクセルの左上隅を中心に回転します。

ただし、サブピクセル サンプルとエリア サンプルのコールバックは、実際には (.0, .0) を直接ヒットとして扱います。これを補正するには、これらの関数を呼び出す前に、x 値と y 値から 0.5 を減算します。

行列関数 ([PF_WorldTransformSuite1](graphics-utility-suites#pf_worldtransformsuite1) から `transform_world`) にはこの問題はありません。

イメージをサブピクセル量で変換する場合は、出力レイヤーを入力より 1 ピクセル広くし、原点を (0,0) のままにします。

---

## テキストレイヤーの原点

ほとんどすべてのレイヤー タイプの原点は左上隅にあります。テキストレイヤーではそうではありません。

デフォルトでは、テキストレイヤーの原点は最初の文字の左下のベースライン位置にあります。これは、テキスト項目を作成し、アンカー ポイントが表示されるようにレイヤーを選択すると確認できます。

デフォルトのアンカーポイントの位置を確認してください。変換はレイヤーの四角形の角ではありません。

---

## 白紙の状態

必ずしもクリーンな出力スレートからエフェクト処理を始める必要はありません。ガウスぼかしフィルターは、これを実現するために、レンダリング前に次の処理を実行します。

```cpp
src_rect.left   = in_data>output_origin_x;
src_rect.right  = src_rect.left + input>width;
src_rect.top    = in_data>output_origin_y;
src_rect.bottom = src_rect.top + input>height;

err = PF_FILL(NULL, NULL, output);

if (!err) {
    err = PF_COPY(&params[0]>u.ld, output, NULL, &src_rect);
}
```
---

## キャッシュ動作

After Effects には、キャッシュ動作を指定するさまざまな方法が用意されています。 `PF_OutFlag_NON_PARAM_VARY`、`PF_OutFlag_WIDE_TIME_INPUT`、`PF_OutFlag_I_USE_SHUTTER_ANGLE`、`PF_OutFlag_I_SYNTHESIZE_AUDIO`、`PF_OutFlag2_I_USE_3D_CAMERA`、`PF_OutFlag2_I_USE_3D_LIGHTS` (すべて [PF_OutFlags](../effect-basics/PF_OutData#pf_outflags) から) はすべて、キャッシュの決定に影響します。

[dynamic outflags](../effect-basics/PF_OutData#pf_outflags) をサポートすると、パフォーマンスが大幅に向上し、After Effects がエフェクトのキャッシュを積極的に無効にするのを防ぐことができます。

プラグインがさまざまな After Effects キャッシュ設定で適切に動作することを確認します。プラグインは期待どおりの頻度で更新のために呼び出されますか、それとも有効なピクセルがないと思われるときに After Effects は有効なピクセルがあると判断しますか?

---

## グローバル パフォーマンス キャッシュに関する考慮事項

CS6 の新しいキャッシュでは、変更前にレンダリングされてキャッシュに保存されたフレームが再利用されないように、エフェクトのレンダリングを変更した後にキャッシュされたフレームをクリアする必要がある場合があります。開発中に手動でこれを行うには:

1. [環境設定] > [メディアとディスク キャッシュ] で、ディスク キャッシュを無効にします。
2. 念のため「ディスク キャッシュを空にする」をクリックします (ステップ 1 でディスク キャッシュを無効にすることは、ディスク キャッシュの *書き込み* を無効にするだけであり、必ずしも使用を無効にするわけではありません)。
3. 再起動

グリッチが発生した場合は、SmartFX での不適切な四角形の処理など、エフェクトの正当なバグである可能性があります。

一方、プラグインのレンダリングのバグを修正してアップデートを配布した場合、すべてのユーザーがディスク キャッシュを空にすることは期待できません。ユーザーはバグのあるフレームのディスク キャッシュを持っている可能性があるため、それを無効にする必要があります。何をするか？プラグインのエフェクトのバージョンを更新します。この値 (および AE ビルド番号) はキャッシュ キーの一部であるため、これを更新すると、プラグインのコンテンツを含むキャッシュされたフレームは一致しなくなります。

---

## 長年の開発者からのタイムリーな意見

Stoney Ballard は、時間が効果にどのように作用するかを次のようにまとめています。役に立つかもしれません。

フィルタまでの時間を記述する `in_data` パラメータが 5 つあります。

- `current_time`
- `time_step`
- `local_time_step`
- `total_time`
- `time_scale`

それらの値は以下に依存します。

- レンダリング中のフレーム
- レイヤーとコンポジションの長さ コンプのフレームレート
- いつでもストレッチ、いつでもリマッピング
- 外側のコンポジションの時間的動作 (フィルタリングされるレイヤーでコンポジションを囲むコンポジション)
- 「ネストまたはレンダー キュー内のフレーム レートを維持」(PFR) スイッチの設定

レンダリングされているフレームは current_time に影響します。ローカル（レイヤー）時間系で表現されます。 PFR スイッチがオフの場合、current_time は負でない任意の値になります。。オンの場合、time_step と local_time_step の倍数に制限されます。レイヤーの継続時間は total_time のみに影響します。コンプ持続時間は、タイム リマッピング (TR) がオンの場合にのみ考慮されます。その場合、total_time はレイヤー期間とコンポジション期間の大きい方になります。コンポジション フレーム レートは time_scale にのみ影響します。タイム ストレッチは、time_step と local_time_step にのみ影響します。タイムストレッチが負の場合、これらの値は負になります。たとえレイヤーの継続時間が長くても (次のように)

comp) が変化しても、total_time は影響を受けません。これは、タイム ストレッチがフィルターの *上にあるが、外側のコンプの *下にあるかのように機能します。 PFR はタイム ストレッチの効果を変更しません。タイム ストレッチは外側のコンプとは異なり、外側のコンプは両方のステップ パラメータに等しく影響しますが、外側のコンプは time_step のみに影響します。

時間の再マッピングはフィルターの「下」で行われるため、total_time 以外の時間パラメーターには影響しません。 TR がオンの場合、実際にかかる時間や、レイヤーがコンプ内のどこにあるかに関係なく、レイヤーはコンプと同じまで延長されます (ただし、短縮されることはありません)。これにより、total_time が大きくなる可能性があります。実際のタイム マップとは関係がなく、有効かどうかだけです。

最大の変化は、PFR がオンでない限り、外側のコンプにネストされていることによって発生します。 PFR がオンの場合、フィルターは外部コンプの時間変動から完全に分離されます。もちろん、その場合、current_time は必ずしも time_step の増分で移動するとは限りません。フレームをスキップしたり、逆に戻ったりする可能性があります。

PFR がオフの場合、local_time_step、total_time、および time_scale は内部コンプの設定のままですが、time_step には外部コンプの次のフレームまでの時間がローカル タイム システムで表されます。これは、0 を含む任意の値です。これは、継続時間ではなく、瞬間的な時間レートとして解釈できます。 0 値はレンダリングされたフレームの任意の数の間持続できますが、current_time はローカル レイヤでは変更されません。

別の方向から見ると:

current_time は、内部コンプの PFR をオフにして外部コンプをレンダリングしない限り、time_step 間隔に量子化されます。これは、コンプ内ではなく、レイヤー内の現在の時間です。

local_time_step の値は、タイム ストレッチの影響のみを受けます。ゼロになることはありませんが、マイナスになることはあります。

time_step と local_time_step は、PFR をオフにして外側のコンプをレンダリングしない限り、常に同じ値です。 time_step は、外側のコンプ (PFR オフの場合) の時間動作にも影響されます。。正、負、またはゼロの任意の値を指定でき、(外側のコンプの) フレームごとに異なる値にすることができます。 time_step を使用して、現在のフレームの継続時間を決定できます (PFR オフの場合)。

total_time は、タイム リマッピングがオンでない限り、レイヤーの継続時間です。これにより、レイヤーの継続時間とコンプの継続時間が長くなります。

time_scale は、total_time / time_scale がコンプ内のレイヤーの継続時間を秒単位で表すようなスケールです。おそらく、何らかの理由ですべての時間値が比例してスケーリングされる可能性がありますが、これはコンプ フレーム レートによってのみ影響を受けます。

レイヤーの固有フレーム レート (存在する場合) はどこにも表示されませんが、通常はコンプ フレーム レートと同じです。フィルタがクリップの実際のフレームにアクセスする必要がある場合は、アクセスできます。

同じフレーム レートのコンプ内にあり、そのレイヤーにタイム ストレッチやタイム リマッピングが適用されていない場合のみです。フレームがどこにあるかを判断するには、local_time_step を使用する必要があります。

---

## レート x 時間 == 苦痛!

パラメータの 1 つが速度または速度パラメータである場合は注意してください。波及効果を考えてみましょう。定数を想定し、現在の時間を使用してリップルに沿ってどこまで進んだかを決定します (d = v \* t)。ユーザーが時間の経過に伴う速度を補間する場合は、時刻 0 から現在時刻までの速度関数を積分する必要があります。リップルはこれを*行いません*が、ユーザーが希望に応じて補間できる「位相」パラメータを提供し、速度がゼロに設定されている限り正しい結果を提供します。正しい動作を提供したい場合は、PF_CHECKOUT_PARAM() を使用して、時間の始まりから現在時間までの速度パラメーターをサンプリング (および統合) するか、「位相」または「距離」パラメーターを提供して、速度の補間についてユーザーに警告することができます。多くのパラメーター値をチェックアウトするコストはレンダリングに比べて無視できるため、推奨されるアプローチです。

他のときにパラメータ値をチェックアウトする場合、またはレイヤー パラメータを使用する場合は、エラーが発生した場合でも、終了時にそれらのパラメータをチェックインする必要があります。チェックアウトされたパラメータは読み取り専用であることに注意してください。

---

## テスト

RAM プレビューでプラグインを使用して、メモリ不足状態を適切に処理できるようにしてください。プラグインはメモリ不足を適切に処理しますか?

メモリをリクエストしたときに `PF_Err_OUT_OF_MEMORY` ([Error Codes](../effect-basics/errors#error-codes) から) を受け取った場合、それを After Effects に返しますか?ビデオエフェクトがオーディオのみのレイヤーに適用されるとどうなりますか?古いバージョンのプラグインを使用して作成されたプロジェクトでテストします。
